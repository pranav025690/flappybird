<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Physics Cubes</title>

  <style>
    /* === GLOBAL RESET === */
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      position: relative;
      background: #111;
      color: #fff;
      font-family: 'Orbitron', sans-serif;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
    }

    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      backdrop-filter: blur(12px);
      background: rgba(0, 0, 0, 0.45);
      z-index: 9999;
      opacity: 1;
      visibility: visible;
      transition: opacity 0.4s ease, visibility 0.4s ease;
    }

    .overlay.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    .menu-center h1 {
      font-size: 80px;
      margin: 0 0 32px 0;
      color: white;
      text-shadow: 0 0 20px rgba(255,255,255,0.3);
    }

    .menu-center button {
      font-size: 20px;
      padding: 10px 30px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      color: white;
      background: #1f6b2a;
      transition: background 0.3s;
    }

    .menu-center button:hover {
      background: #3aa23a;
    }

    .controls-btn {
      position: fixed;
      bottom: 20px;
      left: 20px;
      font-size: 16px;
      padding: 10px 18px;
      border: 1px solid rgba(255,255,255,0.3);
      border-radius: 6px;
      background: rgba(0,0,0,0.4);
      color: white;
      cursor: pointer;
      z-index: 10000;
      transition: background 0.3s;
    }

    .controls-btn:hover {
      background: rgba(0,0,0,0.6);
    }

    .controls-panel {
      background: rgba(0, 0, 0, 0.8);
      padding: 32px 48px;
      border-radius: 10px;
      max-width: 420px;
      color: white;
      text-align: left;
      font-size: 16px;
    }

    .controls-panel h2 {
      text-align: center;
      margin-bottom: 16px;
    }

    .controls-panel ul {
      list-style: none;
      padding: 0;
      margin: 0 0 20px 0;
    }

    .controls-panel li {
      margin: 8px 0;
    }

    .controls-panel button {
      display: block;
      margin: 0 auto;
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      background: #1f6b2a;
      color: white;
      cursor: pointer;
      transition: background 0.3s;
    }

    .controls-panel button:hover {
      background: #3aa23a;
    }
  </style>
</head>
<body>
 <div id="mainMenu" class="overlay visible">
  <div class="menu-center">
    <h1>QUBE</h1>
    <button id="startGame">Start</button>
  </div>
</div>

<button id="controlsBtn" class="controls-btn">Controls</button>

<div id="controlsMenu" class="overlay hidden">
  <div class="controls-panel">
    <h2>Controls</h2>
    <ul>
      <li><b>Space</b> – Add Cube</li>
      <li><b>Backspace</b> – Delete All Cubes</li>
      <li><b>R</b> – Shatter Cube</li>
      <li><b>W / A / S / D</b> – Move Camera</li>
      <li><b>Right Click + Drag</b> – Look Around</li>
      <li><b>Left Click</b> – Pick / Drag Cube</li>
      <li><b>Q / E</b> – Adjust Drag Distance</li>
    </ul>
    <button id="closeControls">Back</button>
  </div>
</div>


  <script type="module">
    import * as THREE from "https://esm.sh/three@0.165.0";
    import * as CANNON from "https://esm.sh/cannon-es@0.20.0";

    const scene = new THREE.Scene();

    // --- CAMERA ---
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 3, 8);

    // --- RENDERER ---
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.6;
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

        // --- PHYSICS WORLD ---
const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -35.0, 0) });

const islandRadius = 14; // bigger island
const islandTopY = 0;    // flat top at y = 0
const islandHeight = 3.6; // thicker slab for a more solid island

// visual top (green circular top)
const topGeo = new THREE.CircleGeometry(islandRadius, 64);
topGeo.rotateX(-Math.PI / 2);
const topMat = new THREE.MeshStandardMaterial({ color: 0x3aa23a, roughness: 0.7 });
const islandTop = new THREE.Mesh(topGeo, topMat);
islandTop.receiveShadow = true;
islandTop.position.y = islandTopY + 0.04; // slightly higher to avoid z-fighting with skirt
scene.add(islandTop);

// brown skirt (thick side/bottom appearance)
const skirtGeo = new THREE.CylinderGeometry(islandRadius, islandRadius, islandHeight, 64, 1, false);
const skirtMat = new THREE.MeshStandardMaterial({ color: 0x6b4a2a, roughness: 1.0 });
const skirt = new THREE.Mesh(skirtGeo, skirtMat);
// position so top of skirt sits just below the green top
skirt.position.y = islandTopY - islandHeight / 2 - 0.02;
skirt.castShadow = true;
skirt.receiveShadow = true;
scene.add(skirt);

// physics: static thin cylinder so cubes rest on island top (same height as visual slab)
const islandShape = new CANNON.Cylinder(islandRadius, islandRadius, islandHeight, 32);
const islandBody = new CANNON.Body({ mass: 0 });
islandBody.addShape(islandShape);
islandBody.position.set(0, islandTopY - islandHeight / 2, 0);
world.addBody(islandBody);

// --- POND --- (moved to the side and sits clearly on the visible top)
const pondRadius = islandRadius * 0.34; // keep larger pond
const pondDepth = 0.08;
const pondBaseGeo = new THREE.CircleGeometry(pondRadius, 64);
pondBaseGeo.rotateX(-Math.PI / 2);
const pondBaseMat = new THREE.MeshStandardMaterial({
  color: 0x1e82ff,
  roughness: 0.04,
  metalness: 0.2,
  transparent: true,
  opacity: 0.94
});
const pond = new THREE.Mesh(pondBaseGeo, pondBaseMat);
// move pond to the side and place it slightly above the island top to avoid z-fighting
pond.position.set(0, islandTop.position.y + 0.004, -islandRadius * 0.60);
  pond.receiveShadow = true;
  scene.add(pond);

// subtle rim for pond (unchanged)
const rimGeo = new THREE.RingGeometry(pondRadius * 0.90, pondRadius * 1.04, 64);
rimGeo.rotateX(-Math.PI / 2);
const rimMat = new THREE.MeshStandardMaterial({ color: 0x234f3a, roughness: 1.0 });
const rim = new THREE.Mesh(rimGeo, rimMat);
rim.position.copy(pond.position);
rim.receiveShadow = true;
scene.add(rim);

// main sun (directional) — warm, high, casts crisp shadows
const sun = new THREE.DirectionalLight(0xfff2c4, 2.0);
sun.position.set(40, 80, -30);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
sun.shadow.camera.left = -120;
sun.shadow.camera.right = 120;
sun.shadow.camera.top = 120;
sun.shadow.camera.bottom = -120;
sun.shadow.camera.near = 1;
sun.shadow.camera.far = 600;
sun.shadow.bias = -0.0005;
scene.add(sun);

// gentle ambient fill to avoid dark occluded areas
const ambient = new THREE.AmbientLight(0xffffff, 0.28);
scene.add(ambient);

// visible sun disc (visual only)
const sunDiscMat = new THREE.MeshBasicMaterial({ color: 0xfff2a6, toneMapped: false });
const sunDisc = new THREE.Mesh(new THREE.SphereGeometry(4, 16, 16), sunDiscMat);
sunDisc.position.copy(sun.position).normalize().multiplyScalar(180);
scene.add(sunDisc);

// deep blue sky (large inverted sphere)
const skyGeo = new THREE.SphereGeometry(800, 32, 16);
const skyMat = new THREE.MeshBasicMaterial({ color: 0x4faeff, side: THREE.BackSide }); // deeper blue
const sky = new THREE.Mesh(skyGeo, skyMat);
scene.add(sky);

// aim sun at island center for consistent lighting
sun.target.position.set(0, 0, 0);
scene.add(sun.target);

// reduce exposure slightly so no crushed blacks
renderer.toneMappingExposure = 1.25;

// --- BIGGER LAYERED PYRAMID TREE (taller trunk, better overlap) ---
function addPyramidTree(x, z, layers = 6, baseSize = 2.2, layerHeight = 1.0) {
  // taller trunk so foliage covers it
  const trunkHeight = Math.max(2.6, layers * (layerHeight * 0.95));
  const trunkRadiusTop = 0.22 * (baseSize / 1.8);
  const trunkRadiusBottom = 0.28 * (baseSize / 1.8);
  const trunkGeo = new THREE.CylinderGeometry(trunkRadiusTop, trunkRadiusBottom, trunkHeight, 12);
  const trunkMat = new THREE.MeshStandardMaterial({ color: 0x684021, roughness: 1.0 });
  const trunk = new THREE.Mesh(trunkGeo, trunkMat);
  trunk.position.set(x, islandTopY + trunkHeight / 2 - 0.05, z);
  trunk.castShadow = true;
  scene.add(trunk);

  // stacked pyramids: start slightly above trunk top and overlap heavily
  const leafMatBase = new THREE.MeshStandardMaterial({ color: 0x1f6b2a, roughness: 0.55 });
  const startY = islandTopY + trunkHeight - (layerHeight * 0.3);
  for (let i = 0; i < layers; i++) {
    const t = i / Math.max(1, layers - 1);
    const size = baseSize * (1 - t * 0.7);
    const height = layerHeight * (1 - t * 0.12);
    const seg = 4;
    const coneGeo = new THREE.ConeGeometry(size, height, seg);
    coneGeo.rotateY(Math.PI / 4);
    const leafMat = leafMatBase.clone();
    const cone = new THREE.Mesh(coneGeo, leafMat);
    // overlap each layer by ~70% so trunk is hidden
    const y = startY + i * (height * 0.7);
    cone.position.set(x + (Math.random() - 0.5) * 0.08, y, z + (Math.random() - 0.5) * 0.08);
    cone.rotation.y = (Math.random() - 0.5) * 0.4;
    cone.castShadow = true;
    scene.add(cone);
  }
}

// place trees near the outer rim (edge)
addPyramidTree(-islandRadius * 0.78, islandRadius * 0.20, 8, 2.6, 1.1); // left
addPyramidTree(islandRadius * 0.78, islandRadius * -0.18, 6, 1.8, 0.95); // right

    // --- CUBES STORAGE ---
    const cubes = [];
const fragments = []; // { mesh, body, born, life }
const flashes = [];   // { light, born, life }

    function addCube() {
      const size = 1;
      const cubeShape = new CANNON.Box(new CANNON.Vec3(size / 2, size / 2, size / 2));
      const cubeBody = new CANNON.Body({
        mass: 1,
        shape: cubeShape,
        position: new CANNON.Vec3(
          (Math.random() - 0.5) * 6,
          3 + Math.random() * 3,
          (Math.random() - 0.5) * 6
        )
      });
      cubeBody.linearDamping = 0.2;
      world.addBody(cubeBody);

      const cubeMesh = new THREE.Mesh(
        new THREE.BoxGeometry(size, size, size),
        new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff, roughness: 0.4, metalness: 0.2 })
      );
      cubeMesh.castShadow = true;
      scene.add(cubeMesh);

      cubes.push({ body: cubeBody, mesh: cubeMesh });
    }

    function deleteAllCubes() {
      cubes.forEach(c => {
        scene.remove(c.mesh);
        world.removeBody(c.body);
      });
      cubes.length = 0;
    }

    // --- SHATTER EFFECT ---
function shatterCube(cube) {
  const { mesh, body } = cube;
  const origin = new THREE.Vector3().copy(mesh.position);
  const baseColor = mesh.material && mesh.material.color ? mesh.material.color.clone() : new THREE.Color(0xffffff);

  // remove original cube (Cannon body removed)
  scene.remove(mesh);
  try { world.removeBody(body); } catch (e) {}
  const ci = cubes.indexOf(cube);
  if (ci !== -1) cubes.splice(ci, 1);

  // brief flash
  const flashLight = new THREE.PointLight(0xffe0c8, 5, 10, 2);
  flashLight.position.copy(origin);
  scene.add(flashLight);
  flashes.push({ light: flashLight, born: performance.now(), life: 180 });

  // fragments: lightweight manual simulation (no Cannon bodies)
  const cubeVel = body && body.velocity ? new THREE.Vector3(body.velocity.x, body.velocity.y, body.velocity.z) : new THREE.Vector3();
  const pieceCount = Math.min(20, 10 + Math.floor(Math.random() * 12)); // keep count reasonable

  for (let i = 0; i < pieceCount; i++) {
    const pSize = 0.04 + Math.random() * 0.20;
    const geom = new THREE.BoxGeometry(pSize, pSize, pSize);

    const color = baseColor.clone().offsetHSL((Math.random()-0.5)*0.08, (Math.random()-0.5)*0.12, (Math.random()-0.5)*0.12);
    const mat = new THREE.MeshStandardMaterial({
      color,
      roughness: 0.45 + Math.random()*0.45,
      metalness: 0.0,
      transparent: true,
      opacity: 1
    });

    const pieceMesh = new THREE.Mesh(geom, mat);
    pieceMesh.castShadow = true;

    const localOffset = new THREE.Vector3(
      (Math.random()-0.5) * 0.8,
      (Math.random()-0.5) * 0.8,
      (Math.random()-0.5) * 0.8
    ).multiplyScalar(0.5);
    pieceMesh.position.copy(origin).add(localOffset);
    pieceMesh.quaternion.set(Math.random(), Math.random(), Math.random(), Math.random()).normalize();

    scene.add(pieceMesh);

    // initial velocity (outward + inherited)
    const outDir = new THREE.Vector3().subVectors(pieceMesh.position, origin);
    if (outDir.lengthSq() < 1e-6) outDir.set((Math.random()-0.5), (Math.random()-0.3), (Math.random()-0.5));
    outDir.normalize();
    const speed = 2.0 + Math.random() * 5.0;
    const vel = new THREE.Vector3(
      cubeVel.x + outDir.x * speed,
      cubeVel.y + outDir.y * speed + 1.0 * Math.random(),
      cubeVel.z + outDir.z * speed
    );

    // angular velocity (radians/sec)
    const angVel = new THREE.Vector3((Math.random()-0.5)*6, (Math.random()-0.5)*6, (Math.random()-0.5)*6);

    fragments.push({
      mesh: pieceMesh,
      pos: pieceMesh.position.clone(),
      vel,
      angVel,
      size: pSize,
      born: performance.now(),
      life: 1800 + Math.random() * 1600
    });
  }
}

    // --- INITIAL CUBE ---
    addCube();

    window.addEventListener("keydown", e => {
  const k = e.key.toLowerCase();

});
    // --- INPUT & CAMERA ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let isLeftDown = false;
    let isRightDown = false;
    let draggingCube = null;
    let grabOffset = new THREE.Vector3();
    let targetPos = new THREE.Vector3();
    let prevMouse = new THREE.Vector2();
    let yaw = 0;
    let pitch = -0.1;
    const keys = {};

    let dragDistance = 5;
    const dragStep = 3;
    const dragMin = 1;
    const dragMax = 80;

    window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
    window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

    window.addEventListener("keydown", e => {
      const k = e.key.toLowerCase();
      if (k === "q") {
        dragDistance = Math.max(dragMin, dragDistance - dragStep);
        if (draggingCube) draggingCube.grabDistance = dragDistance;
      } else if (k === "e") {
        dragDistance = Math.min(dragMax, dragDistance + dragStep);
        if (draggingCube) draggingCube.grabDistance = dragDistance;
      } else if (k === "r") {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(cubes.map(c => c.mesh), false);
        if (intersects.length > 0) {
          const picked = intersects[0].object;
          const cube = cubes.find(c => c.mesh === picked);
          if (cube) shatterCube(cube);
        }
      }
    });

    window.addEventListener("mousedown", e => {
      if (e.button === 0) { isLeftDown = true; tryPickCube(); }
      if (e.button === 2) isRightDown = true;
      prevMouse.set(e.clientX, e.clientY);
    });

    window.addEventListener("mouseup", e => {
      if (e.button === 0) { isLeftDown = false; draggingCube = null; }
      if (e.button === 2) isRightDown = false;
    });

    window.addEventListener("mousemove", e => {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

      if (isRightDown) {
        const dx = e.clientX - prevMouse.x;
        const dy = e.clientY - prevMouse.y;
        yaw -= dx * 0.005;
        pitch -= dy * 0.005;
        pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
      }
      prevMouse.set(e.clientX, e.clientY);
    });

    window.addEventListener("contextmenu", e => e.preventDefault());

    function tryPickCube() {
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(cubes.map(c => c.mesh), false);
      if (intersects.length > 0) {
        const picked = intersects[0].object;
        draggingCube = cubes.find(c => c.mesh === picked);
        grabOffset.copy(intersects[0].point).sub(draggingCube.mesh.position);
        dragDistance = intersects[0].distance;
        draggingCube.grabDistance = dragDistance;
        if (draggingCube.body.wakeUp) draggingCube.body.wakeUp();
      }
    }

    function updateCamera(dt) {
      const speed = 5 * dt;
      const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)).normalize();
      const right = new THREE.Vector3(forward.z, 0, -forward.x);
      if (keys["w"]) camera.position.addScaledVector(forward, speed);
      if (keys["s"]) camera.position.addScaledVector(forward, -speed);
      if (keys["a"]) camera.position.addScaledVector(right, speed);
      if (keys["d"]) camera.position.addScaledVector(right, -speed);

      const lookTarget = new THREE.Vector3(
        camera.position.x + Math.sin(yaw) * Math.cos(pitch),
        camera.position.y + Math.sin(pitch),
        camera.position.z + Math.cos(yaw) * Math.cos(pitch)
      );
      camera.lookAt(lookTarget);
    }

function _updateFragmentsAndFlashes(dt) {
  const now = performance.now();

  // flashes (light burst)
  for (let i = flashes.length - 1; i >= 0; i--) {
    const f = flashes[i];
    const t = (now - f.born) / f.life;
    if (t >= 1) {
      scene.remove(f.light);
      flashes.splice(i, 1);
      continue;
    }
    const intensity = Math.max(0, (1 - t)) * 5;
    f.light.intensity = intensity;
    f.light.distance = 6 * (1 - t) + 0.5;
  }

  // fragments: simple integrator with gravity + floor bounce + fade
  const gravity = new THREE.Vector3(0, -35.0, 0);
  for (let i = fragments.length - 1; i >= 0; i--) {
    const p = fragments[i];

    // integrate linear motion
    p.vel.addScaledVector(gravity, dt); // v += g * dt
    p.pos.addScaledVector(p.vel, dt);   // x += v * dt
    p.mesh.position.copy(p.pos);

    // integrate rotation using angular velocity (axis-angle)
    const omega = p.angVel.length();
    if (omega > 1e-5) {
      const axis = p.angVel.clone().normalize();
      const angle = omega * dt;
      const dq = new THREE.Quaternion().setFromAxisAngle(axis, angle);
      p.mesh.quaternion.multiplyQuaternions(dq, p.mesh.quaternion).normalize();
    }

    // simple floor collision (floor at y=0)
    const minY = p.size * 0.5;
    if (p.pos.y <= minY) {
      p.pos.y = minY;
      // damp and bounce
      p.vel.y = -p.vel.y * 0.28;
      // apply friction to horizontal velocity
      p.vel.x *= 0.6;
      p.vel.z *= 0.6;
      // reduce angular velocity
      p.angVel.multiplyScalar(0.6);
    }

    // fade out and increase roughness slightly
    const age = now - p.born;
    const remain = 1 - age / p.life;
    if (p.mesh.material) {
      p.mesh.material.opacity = Math.max(0, remain);
      p.mesh.material.roughness = Math.min(1, 0.5 + (1 - remain) * 0.6);
      p.mesh.material.needsUpdate = true;
    }

    if (age > p.life || p.pos.y < -20) {
      scene.remove(p.mesh);
      fragments.splice(i, 1);
    }
  }
}
    // --- MENU LOGIC ---
    const mainMenu = document.getElementById("mainMenu");
    const controlsMenu = document.getElementById("controlsMenu");
    const startGameBtn = document.getElementById("startGame");
    const controlsBtn = document.getElementById("controlsBtn");
    const closeControlsBtn = document.getElementById("closeControls");

    let inMenu = true;

    startGameBtn.addEventListener("click", () => {
      mainMenu.classList.add("hidden");
      inMenu = false;
    });

    controlsBtn.addEventListener("click", () => {
      controlsMenu.classList.remove("hidden");
    });

    closeControlsBtn.addEventListener("click", () => {
      controlsMenu.classList.add("hidden");
    });

    const clock = new THREE.Clock();
    const fixedStep = 1 / 60;

    function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();

  updateCamera(dt);

  if (draggingCube && isLeftDown) {
    raycaster.setFromCamera(mouse, camera);
    const dir = raycaster.ray.direction.clone().normalize();
    const distance = draggingCube.grabDistance || dragDistance;
    targetPos.copy(raycaster.ray.origin).add(dir.multiplyScalar(distance));

    const desiredPos = new THREE.Vector3().copy(targetPos).sub(grabOffset);
    const cBody = draggingCube.body;
    const bodyPos = new THREE.Vector3(cBody.position.x, cBody.position.y, cBody.position.z);

    const stiffness = 8 + distance * 3;
    const maxSpeed = 30 + distance * 3;
    const toTarget = new THREE.Vector3().subVectors(desiredPos, bodyPos);
    const desiredVel = toTarget.multiplyScalar(stiffness);
    if (desiredVel.length() > maxSpeed) desiredVel.setLength(maxSpeed);

    cBody.velocity.x = desiredVel.x;
    cBody.velocity.y = desiredVel.y;
    cBody.velocity.z = desiredVel.z;
  }

  world.step(fixedStep);

  cubes.forEach(c => {
    c.mesh.position.copy(c.body.position);
    c.mesh.quaternion.copy(c.body.quaternion);
  });

  // update fragments and flashes (pass dt in seconds)
  _updateFragmentsAndFlashes(dt);

  renderer.render(scene, camera);
}

// call animate once to start the loop
animate();
  </script>
</body>
</html>
